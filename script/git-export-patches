#!/usr/bin/env python

import argparse
import os
import sys

from lib.patches import guess_base_commit, format_patch, split_patches, get_file_name, remove_patch_filename

def main(argv):
  parser = argparse.ArgumentParser()
  parser.add_argument("-o", "--output",
      help="directory into which exported patches will be written",
      required=True)
  parser.add_argument("patch_range",
      nargs='?',
      help="range of patches to export. Defaults to all commits since the "
           "most recent tag or remote branch.")
  args = parser.parse_args(argv)

  repo = '.'
  patch_range = args.patch_range
  if patch_range is None:
    patch_range, num_patches = guess_base_commit(repo)
    sys.stderr.write("Exporting {} patches since {}\n".format(num_patches, patch_range))
  patch_data = format_patch(repo, patch_range)
  patches = split_patches(patch_data)

  out_dir = args.output
  try:
    os.mkdir(out_dir)
  except OSError:
    pass

  # remove old patches, so that deleted commits are correctly reflected in the
  # patch files (as a removed file)
  for p in os.listdir(out_dir):
    if p.endswith('.patch'):
      os.remove(os.path.join(out_dir, p))

  with open(os.path.join(out_dir, '.patches'), 'w') as pl:
    for patch in patches:
      filename = get_file_name(patch)
      with open(os.path.join(out_dir, filename), 'w') as f:
        f.write('\n'.join(remove_patch_filename(patch)).rstrip('\n') + '\n')
      pl.write(filename + '\n')


if __name__ == '__main__':
  main(sys.argv[1:])
